
# 《TypeScript编程》读书笔记

[豆瓣链接](https://book.douban.com/subject/35134660/)

## 型变

### 子类型

定义如下记号：

1. `A <: B`指“A类型是B类型的子类型，或则为同种类型”
2. `A >: B`指“A类型是B类型的超类型，或者为同种类型”

如果需要类型`T`，定义如下四种型变：

1. 不变：只能是T。
2. 协变：可以是`<: T`
3. 逆变：可以是`>: T`
4. 双变：可以是`>: T`或者`<: T`

在TypeScript中，每个复杂类型的成员都会进行协变，
包括对象、类、数组和函数的返回类型，但是，函数的参数类型进行协变。

### 函数的子类型

如果函数A的参数数量小于或等于函数B的参数数量，而且满足下述条件，
那么函数A是函数B的子类型：

1. 函数A的`this`类型未指定，或者`>:`函数B`this`类型。
2. 函数A的各个参数的类型`>:`函数B的相应参数。
3. 函数A的返回类型`<:`函数B的返回类型。

通俗的讲，就是函数的参数类型只能泛化，不能窄化，返回类型只能窄化，不能泛化。
试想，如果一个函数在更泛的类型的参数上操作，那么传入更窄的类型的参数时，也必定能成功操作。
所以，如果函数A接受更窄的类型的参数，函数B接收更加泛的类型的参数，那么就可以把A赋值给B，
就是B是A的超类型，A是B的子类型。
虽然A是B的子类型，但是A的参数的类型确实B的参数的超类型，这就是逆变。

函数的返回类型是协变的，数组和对象也是94-协变的。

### 可赋值性

如果A可以赋值给B，那么需要满足以下条件之一：

1. `A <: B`
2. A是any

如果是`enum`或者是`const enum`，那么需要满足以下条件之一：

1. A是枚举B的成员
2. B至少有一个成员是`number`类型，而且A是`number`类型

第二条规则导致了`enum`不安全，所以不要使用`enum`。

